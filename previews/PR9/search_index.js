var documenterSearchIndex = {"docs":
[{"location":"","page":"API","title":"API","text":"CurrentModule = MacroUtilities","category":"page"},{"location":"#API","page":"API","title":"API","text":"","category":"section"},{"location":"#General-Utilities","page":"API","title":"General Utilities","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"@assert_type ","category":"page"},{"location":"#MacroUtilities.@assert_type","page":"API","title":"MacroUtilities.@assert_type","text":"@assert_type var types\n\nEnsures that typeof(var) is in the list of provided types.\n\ntypes can be either a single type or a tuple or vect expression of types\n\n\n\n\n\n","category":"macro"},{"location":"#Keyword-Arg-Parsing","page":"API","title":"Keyword Arg Parsing","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"@parse_kwargs ","category":"page"},{"location":"#MacroUtilities.@parse_kwargs","page":"API","title":"MacroUtilities.@parse_kwargs","text":"@parse_kwargs [args] kwarg_spec\n\nParses the set of keyword expressions given in args according to a series of kwarg_spec specification and sets the corresponding keys in the calling scope. \n\nkwarg_spec must be a block Expr, with each line consisting of an expression of the form \n\n    key = (expected_type = T)\n\nwhich specifies that for a key-value expression in args of the form key = value, value must have type T.\n\nAn alternative form is \n\n    key = (expected_types = (T1, T2, ..., Tn))\n\nwhich specifies that a key-value expression in args with key = value must have typeof(value) in (T1, T2, ..., Tn)\n\nIf the default key is provided, e.g., \n\n    key = (expected_types = (T1, T2, ..., Tn), default=default_value)\n\nthen key is set to default_value if args do not contain a key = value expression. \n\nIf the default key is not provided, then args must contain a key = value expression or an ArgumentError will be thrown. \n\nAn alternative, more compact, form to the above expressions is\n\n    key::Union{T1, T2, ..., Tn} = default_value\n\n\n\n\n\n","category":"macro"},{"location":"#Syntax-Parsing","page":"API","title":"Syntax Parsing","text":"","category":"section"},{"location":"#General","page":"API","title":"General","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"from_expr\nto_expr\nNotProvided\nis_not_provided","category":"page"},{"location":"#MacroUtilities.from_expr","page":"API","title":"MacroUtilities.from_expr","text":"from_expr(::Type{T}, expr; throw_error::Bool=false, kwargs...)\n\nParses an expr into an object of type T\n\nThe provided kwargs are passed to the underlying parsing function. \n\nIf expr cannot be parsed into an object of type T     - if throw_error == true, throws an ArgumentError     - otherwise, returns nothing  \n\n====================\n\nfrom_expr(::Type{Vector{T}}, expr::Expr; throw_error::Bool=false)\n\nParses a tuple or vect expr as a Vector{T}. Each argument of expr must be of type T\n\n====================\n\nfrom_expr(::Type{Vector{T}}, input::T; throw_error::Bool=false)\n\nReturns a singleton Vector{T} containing input\n\n====================\n\nfrom_expr(::Type{FuncCall}, expr; normalize_kwargs::Bool=false)\n\nReturns a parsed FuncCall from expr\n\nIf normalize_kwargs = true, trailing equality expressions (e.g., f(a, b, c=1) will be parsed as keyword arguments. \n\n\n\n\n\n","category":"function"},{"location":"#MacroUtilities.to_expr","page":"API","title":"MacroUtilities.to_expr","text":"to_expr(x) -> Expr\n\nConverts x to an Expr representation\n\n\n\n\n\n","category":"function"},{"location":"#MacroUtilities.NotProvided","page":"API","title":"MacroUtilities.NotProvided","text":"NotProvided\n\nPlaceholder type to represent the absence of a field.\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.is_not_provided","page":"API","title":"MacroUtilities.is_not_provided","text":"is_not_provided(x) -> Bool\n\nReturns true if the field corresponding to x is not provided, false otherwise. \n\n\n\n\n\n","category":"function"},{"location":"#Expression-Types","page":"API","title":"Expression Types","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"AssignExpr\nBlockExpr\nKVExpr\nKeyWOptions\nNestedDotExpr\nExprWOptionalRhs\nExprWOptions","category":"page"},{"location":"#MacroUtilities.AssignExpr","page":"API","title":"MacroUtilities.AssignExpr","text":"AssignExpr(; lhs, rhs, allow_kw)\n\nMatches a lhs = rhs assignment expression. \n\nIf allow_key == true, also matches an assignment expression with head :kw\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.BlockExpr","page":"API","title":"MacroUtilities.BlockExpr","text":"BlockExpr(; args)\n\nMatches a :block expression\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.KVExpr","page":"API","title":"MacroUtilities.KVExpr","text":"KVExpr(; lhs::Symbol, rhs)\n\nMatches an expression of the form lhs = rhs or lhs\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.KeyWOptions","page":"API","title":"MacroUtilities.KeyWOptions","text":"KeyWOptions(; lhs::Symbol, options::NamedTupleExpr)\n\nMatches an expression of the form lhs = (key1=value1, ...) or lhs\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.NestedDotExpr","page":"API","title":"MacroUtilities.NestedDotExpr","text":"NestedDotExpr(; keys::Vector{Symbol})\n\nMatches expressions of the form A.B.C...., with each symbol being stored in keys\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.ExprWOptionalRhs","page":"API","title":"MacroUtilities.ExprWOptionalRhs","text":"ExprWOptionalRhs{E <: AbstractExpr}(; lhs::E, default=not_provided)\n\nMatches an expression of the form lhs = default, where lhs is matched by E, or an expression matched by E\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.ExprWOptions","page":"API","title":"MacroUtilities.ExprWOptions","text":"ExprWOptions{E}(; lhs::E, options::NamedTupleExpr)\n\nMatches an expression of the form lhs = (key1=value1, ...) or lhs, where lhs matches E\n\n\n\n\n\n","category":"type"},{"location":"#Macro-Expressions","page":"API","title":"Macro Expressions","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"MacroCall\ndoc_macro\nassume_effects\nassume_foldable","category":"page"},{"location":"#MacroUtilities.MacroCall","page":"API","title":"MacroUtilities.MacroCall","text":"MacroCall(; name::Union{Symbol, Expr, GlobalRef}, line::Union{LineNumberNode, NotProvided} = not_provided, args::Vector{Any} = [])\n\nMatches a macro call expression. A MacroCall object can be applied to one or more expressions, yielding another MacroCall. \n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.doc_macro","page":"API","title":"MacroUtilities.doc_macro","text":"doc_macro\n\nA MacroCall corresponding to Core.@doc\n\n\n\n\n\n","category":"constant"},{"location":"#MacroUtilities.assume_effects","page":"API","title":"MacroUtilities.assume_effects","text":"assume_effects\n\nA MacroCall corresponding to Base.@assume_effects\n\n\n\n\n\n","category":"constant"},{"location":"#MacroUtilities.assume_foldable","page":"API","title":"MacroUtilities.assume_foldable","text":"assume_foldable\n\nA MacroCall corresponding to Base.@assume_effects :foldable\n\n\n\n\n\n","category":"constant"},{"location":"#Function-Expressions","page":"API","title":"Function Expressions","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"FuncDef\nFuncDef(f::FuncDef)\nFuncCall\nFuncCall(f::FuncCall)\nFuncArg\nFuncArg(f::FuncArg)\nmap_args\nmap_kwargs\nname_only\nnames_only","category":"page"},{"location":"#MacroUtilities.FuncDef","page":"API","title":"MacroUtilities.FuncDef","text":"FuncDef(; header, head, whereparams, return_type, body, line, doc)\n\nMatches a function definition expression\n\nFields\n\nheader::FuncCall\nhead::Symbol\nwhereparams::Any = not_provided\nreturn_type::Any = not_provided\nbody::Any\nline::Union{LineNumberNode, NotProvided} = not_provided\ndoc::Union{String, NotProvided} = not_provided\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.FuncDef-Tuple{FuncDef}","page":"API","title":"MacroUtilities.FuncDef","text":"FuncDef(f::FuncDef; [header, head, whereparams, return_type, body, line, doc)\n\nReturns a new copy of f, with optional header, head, whereparams, return_type, body, line, or doc values overridden by the keyword arguments. \n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.FuncCall","page":"API","title":"MacroUtilities.FuncCall","text":"FuncCall(; funcname, args, kwargs)\n\nMatches a function call expression\n\nFields\n\nfuncname::Union{NotProvided, Symbol, Expr}\nargs::Vector{FuncArg} = Vector{FuncArg}()\nkwargs::OrderedDict{Symbol, FuncArg} = OrderedDict{Symbol, FuncArg}()\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.FuncCall-Tuple{FuncCall}","page":"API","title":"MacroUtilities.FuncCall","text":"FuncCall(f::FuncCall; [funcname, args, kwargs])\n\nReturns a new copy of f, with optional funcname, args, or kwargs overridden by the keyword arguments. \n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.FuncArg","page":"API","title":"MacroUtilities.FuncArg","text":"FuncArg(; name, type, value::Any, is_splat::Bool)\n\nMatches a function argument expression\n\nFields\n\nname::Union{NotProvided, Symbol} = not_provided: Name of the argument\ntype::Union{NotProvided, Symbol, Expr} = not_provided: Annotated type of the argument. Only valid when value is not provided. \nvalue::Any = not_provided: Value of the argument. If name is provided, this corresponds to the default value of name in a method definition. Otherwise, this is the value passed as a function argument \nis_splat::Bool = false: true if this argument is splatted, false otherwise\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.FuncArg-Tuple{FuncArg}","page":"API","title":"MacroUtilities.FuncArg","text":"FuncArg(f::FuncArg; [name, type, value, is_splat])\n\nReturns a new copy of f, with optional name, type, value, or is_splat overridden by the keyword argumnets. \n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.map_args","page":"API","title":"MacroUtilities.map_args","text":"map_args(f, expr::FuncCall) -> FuncCall\nmap_args(f, expr::FuncDef) -> FuncCall\n\nTransform the expr by applying f(FuncArg) -> FuncArg to each of its arguments\n\n\n\n\n\n","category":"function"},{"location":"#MacroUtilities.map_kwargs","page":"API","title":"MacroUtilities.map_kwargs","text":"map_kwargs(f, expr::FuncCall) -> FuncCall\nmap_kwargs(f, expr::FuncDef) -> FuncCall\n\nTransform the expr by applying f(FuncArg) -> FuncArg to each of its keyword arguments\n\n\n\n\n\n","category":"function"},{"location":"#MacroUtilities.name_only","page":"API","title":"MacroUtilities.name_only","text":"name_only(f::FuncArg; is_splat::Bool=f.is_splat) -> FuncArg\n\nReturns a new FuncArg with the type removed from f\n\nIf f.name is provided, also removes the value field from f\n\n\n\n\n\n","category":"function"},{"location":"#MacroUtilities.names_only","page":"API","title":"MacroUtilities.names_only","text":"names_only(f::FuncCall) -> FuncCall\n\nReturns a FuncCall derived from f with all of the types + values removed from \n\n\n\n\n\n","category":"function"},{"location":"#Struct-Expressions","page":"API","title":"Struct Expressions","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"StructDefHeader\nStructDefHeader(h::StructDefHeader)\nStructDefField\nStructDefField(d::StructDefField)\nStructDef\nStructDef(d::StructDef)\nmap_fields","category":"page"},{"location":"#MacroUtilities.StructDefHeader","page":"API","title":"MacroUtilities.StructDefHeader","text":"StructDefHeader(; typename, parameter, supertype)\n\nMatches the header of a struct definition\n\nFields\n\ntypename::Symbol\nparameter::Union{Symbol, Expr, NotProvided} = not_provided\nsupertype::Union{Symbol, Expr, NotProvided} = not_provided\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.StructDefHeader-Tuple{StructDefHeader}","page":"API","title":"MacroUtilities.StructDefHeader","text":"StructDefHeader(f::StructDefHeader; [typename, parameter, supertype])\n\nReturns a new copy of f, with optional typename, parameter, or supertype overridden by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.StructDefField","page":"API","title":"MacroUtilities.StructDefField","text":"StructDefField(; name, type)\n\nMatches a field definition in a struct definition\n\nFields\n\nname::Symbol\ntype::Union{Symbol, Expr, NotProvided}\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.StructDefField-Tuple{StructDefField}","page":"API","title":"MacroUtilities.StructDefField","text":"StructDefField(f::StructDefField; [name, type])\n\nReturns a new copy of f, with optional name or type overridden by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.StructDef","page":"API","title":"MacroUtilities.StructDef","text":"StructDef(; is_mutable, header, lnn, fields, constructors)\n\nMatches a struct definition. The properties .typename, .parameter, and .supertype forward to the header field.\n\nFields\n\nis_mutable::Bool\nheader::StructDefHeader\nlnn::Union{LineNumberNode, NotProvided}\nfields::Vector{Tuple{StructDefField, LineNumberNode}}\nconstructors::Vector{Tuple{FuncDef, LineNumberNode}}\n\n\n\n\n\n","category":"type"},{"location":"#MacroUtilities.StructDef-Tuple{StructDef}","page":"API","title":"MacroUtilities.StructDef","text":"StructDef(f::StructDefField; [is_mutable, header, fields, constructors])\n\nReturns a new copy of f, with optional is_mutable, header, fields, or constructors overridden by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#MacroUtilities.map_fields","page":"API","title":"MacroUtilities.map_fields","text":"map_fields(f, def::StructDef) -> StructDef\n\nApply the function f(::StructDefField) -> StructDefField to each field definition in def\n\n\n\n\n\n","category":"function"}]
}
